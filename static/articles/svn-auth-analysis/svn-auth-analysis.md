## SVN权限解析规则解析

最近在做一个操作SVN的Web系统，涉及到了很多东西，包括apache执行命令、配置文件解析等；编码过程中发现svn的权限解析过程和我所了解到的不大相同，在网上查了一些资料，但好像都是怎么配置svn，没有详细讲解权限的生效过程，而我开发系统需要考虑到各种情况，所以我自己通过一部分资料和动手实验总结了下面的svn权限解析规则。

首先创建一个版本库后，会生成最初的目录结构和基本的配置文件，本文主要分析“authz”文件的内容；我们先抛开alias和groups不谈，将重点放在路径的权限配置上。

### 权限格式

svn权限的基本规则如下：

```conf
[/path]
user1=r
user2=rw
*=
[/path/path2]
user1=rw
```

上面的代码配置了两条路径的权限，'[]'括起来的是路径名，权限的格式是'user=权限'，权限的类别有空、r、rw，上面的*=意思是所有人没有权限。所以上面的配置是：路径/path上user1有读权限，user2有读写权限，其他所有人没有权限；路径/path/paths上user1有读写权限。

### 权限规则

#### 1.在路径上配置过权限的用户（r/rw），无论在其父目录上有无权限，都对该路径有权限，例如：

```conf
[/trunk]
user1=r
*=
[/trunk/app]
user2=rw
*=
```

如上，user1对/trunk有读权限，user2对/trunk/app有读写权限，但是对/trunk没有权限，但是user2仍然可以操作/trunk/app下的内容。之前在TortoiseSVN上查看目录树的时候发现如果父目录没有权限的话是无法查看有权限的子目录的，导致误解为父目录没权限则子目录没权限，后来通过checkout和commit等证实用户对该路径是有权限的。

注：如果父目录没有配置任何权限，在TortoiseSVN目录树中是可以看到有权限的子目录的，但是看不到父目录的其他子目录。

#### 2.在配置文件中，对同一条路径多次配置，会合并所有配置内容，如果有对相同用户的权限配置，则最后的配置生效，例如：

```conf
[/trunk]
user1=rw
user2=rw
*=
[/trunk]
user1=r
```

上面代码对路径/trunk配置了两次，最终效果等同于：

```conf
[/trunk]
user1=r
user2=rw
*=
```

#### 3.如果某路径的配置中包含*=r，那么所有用户的权限最低是r（即使有配置过用户权限为空，如：user=），如果有配置*=rw，则所有用户的权限为rw，例如：

```conf
[/trunk]
user1=
user2=r
user3=rw
*=r
```

效果等价于

```conf
[/trunk]
user1=r
user2=r
user3=rw
*=r
```

效果等价于

```conf
[/trunk]
user3=rw
*=r
```

如果配置*=r，则权限是rw的用户不受影响

总结第1和第3，‘*=’所配置的权限会覆盖本条路径中比它低级的权限配置（即*=r会覆盖用户的空权限配置，*=rw会覆盖r权限和空权限的配置），比它高级的权限则不受影响。

#### 4.如果一条路径的配置（不考虑多次配置）内容中没有*=（或者*=r,*=rw），则该路径会继承父目录的权限，例如：

```conf
[/trunk]
user1=r
*=
[/trunk/app]
user2=rw
```

则路径/trunk/app最终的权限等同于：

```conf
[/trunk/app]
user1=r
user2=rw
*=
```

#### 5.如果一条路径和其父目录对一个用户有不同的权限配置，则访问路径自身的配置生效。其实这点和类的继承很像，子类会继承父类的属性，自己没有定义的属性就直接使用父类的，如果自己定义了，则会覆盖父类的属性。

